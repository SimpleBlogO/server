{
    "AllArticles":[
        {
            "ID":"103037785",
            "title":"gzip源代码阅读与分析",
            "author":"Eayne",
            "content":"gzip该工具在网页中很常用，是在服务器与客户端传递数据的时候将数据进行压缩的工具。\n当然并不是所有的浏览器都支持，通常是通过查看requests的Accept-encoding，这里面包含了浏览器支持的压缩方式。response返回的header中的Content-encoding则包含了服务器压缩的方式，response到达客户端以后再根据压缩方式解压即可。gzip可以达到将近50%的压缩率。\n\n在gzip的代码中，主要是分为下面这几步：\n\n改写响应包头。\n这一步主要是将刚刚所说的response和header中的Content-encoding，添加内容为gzip，表明压缩的方式是gzip，便于浏览器解压\n同时增加\"Vary\" - \"Accept-encoding\"这一项。\n另外会先检查Content-encoding的内容，检查是否已经压缩过\n压缩前删除header中的Content-Length，否则可能会引起浏览器的错误(如safari)。\n写入响应的状态(来自于参数code)\n向Writer写入数据：\n写入数据这一步包括上一步的写入header的数据\n另外设置Content-type(如果先前没设置的话)，会通过http的ContentType检测来写入。\n将传入的其他数据写入Writer\n关闭响应通知\n这个功能主要是用在当客户端那一方关闭连接的时候接收到关闭的通知。类似于TCP连接过程中的一方的断开。\n服务端判断\n如果requests中的Accept-encoding没有包含gzip，就不会压缩\n如果客户端试图进行web-socket的压缩，也不会压缩\n否则的话说明可以压缩。首先从pool中获取一个gzip类，这个池可以通过复用来节约资源，控制流量，也不需要重新分配内存。\n从池中获得的类进行gzip压缩，压缩完后再将这个类放回池中，一直循环这个过程。"
        },
        {
            "ID":"102632898",
            "title":"go与git知识",
            "author":"Eayne",
            "content":"go\n打开文件\n文件打开使用OpenFile函数，这个函数可以指定打开的类型，使用Open打开的是只读的。在打开的函数中进行文件写的时候，os.O_RDWR|os.O_CREATE可以使得往文件末尾附加。os.O_RDWR直接清空后写。清空文件可以使用file.Seek(0,0) file.Truncate(0)``os.O_CREATE在没有文件的时候直接创建(但是如果是要求某个文件夹下的文件，而这个文件还没有，就会错误)\njson\n这里需要用到encoding/json包，该包利用decoder来从file中逐个读取json赋值给map。json的读取是首先用NewDecoder(file)，然后通过Decode(&map[string]interface{})获得转换的map。在Decode时候每次使用，读取文件中下一个json。写则是通过NewEncoder(file)，通过Encode(&map[string]interface{})可以将map转换成json写入文件(写入方式依赖文件打开方式)\n注意常可能需要读取json文件后，修改某个json项的部分。通常是把整个文件读取到buffer，修改完后再写回\nlog\n需要用到log包。通常来说首先创建一个logger(需要指定写入的流，如文件或者buffer等)\n简单的demo：\nlogFile, _ := os.OpenFile(\"logger.txt\", os.O_CREATE|os.O_RDWR|os.O_APPEND, 0600)\nlogger := log.New(logFile, \"logger: \", log.Ldate|log.Ltime)\nusername, _ := cmd.Flags().GetString(\"userName\")\nlogger.Print(\"AgendaGO findUser \")\n1\n2\n3\n4\ncobra：\ncobra 可以用来快速创建CLI文件。\n安装：\n使用go get -v github.com/spf13/cobra/cobra安装\n如果出现无法找到sys或者text，则\ncd $GOPATh/src/golang.org/x (如果不存在先mkdir -p)\n然后用git clone https://golang.org/x/sys以及\ngit clone https://golang.org/x/text\n最后go install githuh.com/spf13/cobra/cobra\n可以到$GOPATH/bin中找到可执行文件cobra\n使用：\n利用cobra构建基本命令行程序\n首先cd到当前项目的文件夹\n然后cobra init初始化后，就用main.go 和cmd文件夹了。\n用命令cobra add 即可cobra add register\ngit\n之前写了篇关于git使用的介绍：https://blog.csdn.net/Eayne/article/details/100806571\n这次项目使用github的时候用到了更多git的知识，这里简单介绍一下：\n\nfork后与原仓库同步\n在fork以后，如果原仓库修改了，想要保持fork后的仓库和原仓库同步。\n\n首先需要理解远程仓库\n\n本地一个仓库，可以连接到多个远程仓库：\n\ngit remote -v可以显示所有的远程仓库信息：\n\norigin -> 自己的远程仓库，可以直接push，pull\n\nupstream -> 原始仓库的远程地址，直接push的话是不能成功的\n\n如果发现自己本地仓库没有原仓库作为upstream，首先先加入：\ngit remote add upstream <git_url>\n\n然后git fetch upstream：可以把原始远程仓库upstream获取(获取方式：下载+创建分支upstream/master)\n\n接下来只需要把upstream/master和master合并即可：\n先切换到master:git checkout master\n\n然后git merge upstream/master\n\n这样就同步成功了。\n\n此外，可以从中知道：\ngit pull是git fetch + git merge的两个加起来的过程。\n\n首先从origin的远程自己的仓库获取代码，然后合并到当前的master\n\nupstream不是自己的远程仓库，不能push。origin是自己的仓库，可以直接push，原理是在github账户上有自己的公钥，而电脑上有自己的私钥，因此两个就可以匹配起来，从而获得验证，可以push。因此如果对一个仓库，想要push的话，就需要先在github账户上设定公钥和自己电脑加上私钥即可。在push的时候，会先要求你输入github的账户密码。"
        },
        {
            "ID":"102892431",
            "title":"go的web应用开发",
            "author":"Eayne",
            "content":"在阅读web应用开发后，下面是一些阅读过程的笔记。\n\nGO 安装\n该部分可以参考我写的文章: Go搭建与go语言\n\nGO语言基础\n该部分可以参考我写的文章: Go搭建与go语言 以及 go与git知识\n\nweb 知识基础\nHTTP：\nHTTP 是应用层协议，传输建立在传输层 TCP 协议基础之上。\n在浏览器中输入一个url以后浏览器与服务器之间发生了什么呢？\n浏览器：请求 DNS 解析 url 得到 ip地址\n浏览器：用 socket 与 服务器 ip地址 发起 TCP 连接请求\n服务器：Accept 客户端请求，建立该连接\n浏览器：向服务器写信息（字符流），Request\n服务器：按浏览器的请求，返回客户端信息（字符流）Response.Response的body内容会包含文件(如html等)\n浏览器：断开连接，让双方释放资源\n其中: Request 与 Response 的约定，就是 HTTP 协议。 HTTP/1.1 标准就是 RFC 2616。\nDNS工作原理：\nDNS是域名服务器解析，在从url获取到ip地址这个过程中往往需要进过多步的判断才能获得。\n下面是一个比较详细的DNS获取过程：\n在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。\n如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。\n如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/IP参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。\n如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。\n如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至 “根DNS服务器”，“根DNS服务器”收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。\n如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管本地DNS服务器用的是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。\nURL和URI的区别\nURI和URL\nURL(定位符)：http://www.baidu.com\nURI(标示符)：https://www.baidu.com/s?ie=utf-8&wd=toy\n（后面的？是query string)\nHTTP request\n主要由body+header组成\nheader包括host，请求命令等\n请求的数据(即url中?后面的放在body中）\n命令可以是：\nGET 读取 uri 指向的信息\nHEAD 查询 uri 指向的信息\nPUT 写入 uri 指向的信息\nDELETE 写入 uri 指向的信息\nPOST 提交表单\nHTTP Response：\n主要由body+header\nheader:\nhost：请求的IP地址\nUser-Agent：提供用户的信息(浏览器类型，操作系统等)\nstate： HTTP/1.1 200 OK (协议，状态编码，状态名称)\n这里的HTTP协议也通常称为scheme\nweb服务器\nweb服务器不仅需要运行，还需要考虑运行的效率\n对于客户端之间的处理请求方式，如果使用阻塞式的会极大的影响效率\n通常的处理方式有以下几种：\n\n协程 + 异步回调（典型 nodejs）\n线程（典型 Java web 服务，如 Tomcat）\n进程服务客户（典型 FastCGI）\n单进程阻塞应用（python tornado） + WSGI\ngo的http包\ngo的net/http包可以快速搭建高并发高性能的web服务器\n在搭建一个简单的服务器的时候，最主要的命令是ListenAndServe函数\n\n参数是string(端口)，handler\n\n这里的handler提供处理对应请求的函数，这里的是提供的接口。\n\n体现了caller和callee的分离，caller就是ListenAndServe这个函数，这个函数调用传入的自定义的handler(callee)函数\n\n如果handler参数是nil，则会使用默认的处理逻辑DefaultServeMux\n\n在http.HandleFunc(\"/\", sayhelloName)这个函数的本质就是把对应的url处理程序(即“/”对应sayhelloname的程序)注入到DefaultServeMux当中\n\n这个函数执行的本质：\n\n形成一个server类，这个类会监听string端口，然后执行handler接口的ServeHTTP函数\n\n自定义DefaultServeMux：\n\n可以通过这个自定义的来进行一些别的功能，比如提取url的path的参数(如/user/name等)\n\nweb框架\n简单应用：net/http\n\n一般应用：“github.com/codegangsta/negroni”\n+“github.com/gorilla/mux”\n+“github.com/unrolled/render”\n\nweb开发：\nbeego，Martini，revel等\n\n压力测试\n可以用ApacheBench\n命令如ab -n 1000 -c 100 http://localhost:9090/hello/your\n\nResponse和Request分析与模拟\n可以用curl命令\n"
        },
        {
            "ID":"102023781",
            "title":"selpg总结",
            "author":"Eayne",
            "content":"主要是在写selpg的go程序的时候，额外的知识(主要是go语言知识)\n\n命令行参数\n参数分两种，一种是用-flag XX类似的方式传入的，另一种没有这样形式的\n\n输入程序的参数本身是保存在os.Args中，可以直接拿来获得，但是这个参数没有解析，可以用下面的flag/pflag来解析\n\nflag包：用来解析输入命令的参数\n\nvar inputName = flag.String(\"name\",\"asd\",\"InputYour nae\") //得到的指针类型。Parse过后直接修改inputName的值。三个参数分别是参数名字，默认值，以及提示。\nvar inputNumber1 = flag.Int(\"number\",123,\"input your number\")\nvar inputNumber2 int\nfunc Init(){\n  flag.IntVar(&inputNumber2,\"number2\",455,\"input number2\")   //可以用这种绑定的方式设定。这里因为a是int所有用IntVar，如果希望用自定义类型，就用flag.Var\n}\nfunc main(){\n  Init()\n  flag.Parse() \n  fmt.Println(*inputName,*inputNumber1,*inputNumber2) //分析后的值\n  fmt.Println(flag.Args(),flag.NArg(),flag.Arg(0)) // 分别是non-flag参数的数组，数量以及第0个non-flag参数的值\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n执行语句大概是这样的go run b.go -number 456 -number2 789 -name yu\n\n在输入参数的时候，上面的number,number2,name等顺序不重要。另外，参数幅值可以是:-flag asd(只用在非bool类型上)或者-flag=asd(所有类型都可以)或者就是-flag(只用在布尔变量上,这样写就表示用true)三种方式。\n\nParse命令如果遇到non-flag的参数就会停止分析。non-flag的参数就是不是以-开头的参数符号。比如go run b.go -number 456 asd -number2 789这样子的话，只有number这个参数会得到456的值，后面的asd,-number2,789都是作为non-flag，放在Args数组中。\n\n另外，如果有带有-开头的参数符号，但是这个符号没有定义(比如说go run b.go -number 56 -sss 123)这样子会报错。报错的时候显示的提示就是在上面代码中的第三个部分。\n\npflag包：\n\n是第三方包，flag的替换包\n\ngo get github.com/spf13/pflag。这样在import的时候就可以直接\"github.com/spf13/pflag\"即可\n\nvar i = pflag.IntP(\"ivalue\",\"i\",100,\"input ivalue\")\n\n这里的i是shorthand。在输入参数的时候是--ivalue 1000或者-i 1000的两种方式\n\n在pflag中是用–来输入参数的方式(--flag,--flag=100,--flag 100)\n\n标准输入\n读取程序的输入(不包括输入的参数)\n\n比如让用户在终端输入/其他文件(file)的输入重定向(<)/其他命令(command)的管道(|)输出定位到该程序的输入都属于这一范围内。后面两者看起来来自其他程序或者文件，其实都来自于os.Stdin，因为经过了重定向到标准输入中。\n\n直接从stdin读入：\n\nfmt的Scanf(读格式化的)/Scanln(读行)都是从os.Stdin 中读取\n\n另外，Sscanf是从字符串中读取。\n\n如果要简单的从文件中读取：Fscanf / Fprint等\n\n利用缓冲区读取：\n\n可以读取os.Stdin或者*File。对于下面的Reader/Writer/Scanner等，可以用它们特有的方法，也可以用Fprint等，因为这个函数可以接受io.Reader/io.Writer接口类型\n\n需要包bufio和os包。本质上bufio就是实现了io.Reader和io.Writer两个接口。其中封装的输入主要是Scanner和Reader,输出封装的主要是Writer,bufio就是用缓冲区读取/写入的方式来实现上述接口。（File类型实际上就是实现了Reader和Writer两个接口，所以可以读也可以写)\n\nReader：\n\ninputReader := bufio.NewReader(os.Stdin) （这样表示从标准输入中读取，如果希望从文件中读取，可以传入*File参数。）\n\n读取是一个字节一个字节读取的。\n\n打开文件：file,err := os.Open(\"filename\")，这里的file是*File\n\nScanner：\n\ninputScanner := bufio.NewScanner(os.Stdin)\n\nfor inputScanner.Scan()… //每次读行。\n\ninputScanner.Text()/Err()//获得本次读取文本/错误\n\n一般来说用Scanner的比较方便\n\n另外bufio应该是没有Close这个函数的。如果使用了*File的话，只需要关闭文件即可\n\n标准错误\nfmt.Fprint(os.Stderr,\"...\")即可写入到标准错误中。\n\n标准输入，标准错误和标准输出在命令行中是有特定的。比如标准输入是0，标准错误是2，标准输出是1\n\n重定向：比如 command 2>&1就是把标准错误重定向到标准输出。commadn >输出重定向,command <是输入重定向，command 2>是标准错误重定向\n\n注意，重定向的来自于文件。管道(|)来自于命令的标准输入输出等\n\n标准输出\nbufio.Writer:\n\noutputWriter := bufio.Writer，也是一个个字节写的。可以是os.Stdout，也可以是传入一个*File\n\n每次往bufio写的时候，必须调用Flush函数，否则写入在writer中的东西不能写出去的。\n\n管道\nos/exec中有exec.Command，该函数可以产生一个子进程，然后这个子进程可以执行指定的命令行命令。要通过Run()这个函数才能让这个子进程运行。\n\n在父进程与子进程之间通信，是通过管道来实现的\n\ngo的管道：io.Pipe()会返回reader和writer。让子进程的Stdin属性为reader。然后往writer写的时候，就可以让command子进程通过reader接收到\n\n另外Command子进程也可以设定Stdout。比如设定为os.Stdout，则这个程序的输出就会显示在显示器上了(如果没有重定向的话)\n\nPipeReader和PipeWriter用完后要Close()\n\n在往PipeWriter中写的时候会阻塞，直到PipeReader中读了或者close才会继续执行。因此通常Writer的write通常用go func(){...}()中写。同理在PipeReader中读的时候也是阻塞的(直到PipeWriter用了Write或者close了)。\n\n通常是go func(){Writer.Write(..) Writer.Close()}()，这样就可以 writer写 -> reader读 -> writer close -> reader 停止阻塞。如果用在Command中，就可以实现把输入先提前通过管道传给Command子进程，然后再让Command子进程执行Run\n\n其他知识\n[]byte转换为字符串：string(数组)即可返回字符串\n"
        }
    ]
}